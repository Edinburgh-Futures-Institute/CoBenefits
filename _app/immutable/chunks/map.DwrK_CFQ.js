import"./transform.Cxf8x_5z.js";import{t as A,u as F,v as O,M as N,w as P,x as z,y as L,l as R,n as T,d as X,o as q,z as Y,A as C,q as Z,B,C as G,D as E,E as M,F as H,G as J,H as K,I as Q,J as U,K as V,L as $,N as W,O as _,P as j,a as tt}from"./index.CqwntdJ0.js";import{c as nt}from"./area.BIxGMRa7.js";function S(t,n=A){if(typeof t[Symbol.iterator]!="function")throw new TypeError("values is not iterable");let e=Array.from(t);const r=new Float64Array(e.length);n.length!==2&&(e=e.map(n),n=A);const a=(c,l)=>n(e[c],e[l]);let o,u;return t=Uint32Array.from(e,(c,l)=>l),t.sort(n===A?(c,l)=>F(e[c],e[l]):O(a)),t.forEach((c,l)=>{const i=a(c,o===void 0?c:o);i>=0?((o===void 0||i>0)&&(o=c,u=l),r[c]=u):r[c]=NaN}),r}const et={ariaLabel:"dot",fill:"none",stroke:"currentColor",strokeWidth:1.5};function rt(t){return t.sort===void 0&&t.reverse===void 0?G({channel:"-r"},t):t}class at extends N{constructor(n,e={}){const{x:r,y:a,r:o,rotate:u,symbol:c=E,frameAnchor:l}=e,[i,f]=M(u,0),[m,h]=P(c),[p,x]=M(o,m==null?3:4.5);super(n,{x:{value:r,scale:"x",optional:!0},y:{value:a,scale:"y",optional:!0},r:{value:p,scale:"r",filter:z,optional:!0},rotate:{value:i,optional:!0},symbol:{value:m,scale:"auto",optional:!0}},rt(e),et),this.r=x,this.rotate=f,this.symbol=h,this.frameAnchor=L(l);const{channels:b}=this,{symbol:y}=b;if(y){const{fill:w,stroke:g}=b;y.hint={fill:w?w.value===y.value?"color":"currentColor":this.fill??"currentColor",stroke:g?g.value===y.value?"color":"currentColor":this.stroke??"none"}}}render(n,e,r,a,o){const{x:u,y:c}=e,{x:l,y:i,r:f,rotate:m,symbol:h}=r,{r:p,rotate:x,symbol:b}=this,[y,w]=H(this,a),g=b===E,I=f?void 0:p*p*Math.PI;return J(p)&&(n=[]),R("svg:g",o).call(T,this,a,o).call(X,this,{x:l&&u,y:i&&c}).call(D=>D.selectAll().data(n).enter().append(g?"circle":"path").call(q,this).call(g?v=>{v.attr("cx",l?s=>l[s]:y).attr("cy",i?s=>i[s]:w).attr("r",f?s=>f[s]:p)}:v=>{v.attr("transform",Y`translate(${l?s=>l[s]:y},${i?s=>i[s]:w})${m?s=>` rotate(${m[s]})`:x?` rotate(${x})`:""}`).attr("d",f&&h?s=>{const d=C();return h[s].draw(d,f[s]*f[s]*Math.PI),d}:f?s=>{const d=C();return b.draw(d,f[s]*f[s]*Math.PI),d}:h?s=>{const d=C();return h[s].draw(d,I),d}:(()=>{const s=C();return b.draw(s,I),s})())}).call(Z,this,r)).node()}}function ht(t,{x:n,y:e,...r}={}){return r.frameAnchor===void 0&&([n,e]=B(n,e)),new at(t,{...r,x:n,y:e})}function dt(t,n={}){let{y:e,y1:r,y2:a}=n;e===void 0&&r===void 0&&a===void 0&&(n={...n,y:e=tt});const o={};return e!=null&&(o.y=t),r!=null&&(o.y1=t),a!=null&&(o.y2=t),ot(o,n)}function ot(t={},n={}){const e=K(n),r=Object.entries(t).map(([a,o])=>{const u=Q(a,n);if(u==null)throw new Error(`missing channel: ${a}`);const[c,l]=U(u);return{key:a,input:u,output:c,setOutput:l,map:st(o)}});return{...V(n,(a,o)=>{const u=$(a,e),c=r.map(({input:i})=>$(a,i)),l=r.map(({setOutput:i})=>i(new Array(a.length)));for(const i of o)for(const f of u?W(i,m=>u[m]).values():[i])r.forEach(({map:m},h)=>m.mapIndex(f,c[h],l[h]));return{data:a,facets:o}}),...Object.fromEntries(r.map(({key:a,output:o})=>[a,o]))}}function st(t){if(t==null)throw new Error("missing map");if(typeof t.mapIndex=="function")return t;if(typeof t.map=="function"&&_(t))return lt(t);if(typeof t=="function")return k(j(t));switch(`${t}`.toLowerCase()){case"cumsum":return it;case"rank":return k((n,e)=>S(n,r=>e[r]));case"quantile":return k((n,e)=>ct(n,r=>e[r]))}throw new Error(`invalid map: ${t}`)}function lt(t){return console.warn("deprecated map interface; implement mapIndex instead."),{mapIndex:t.map.bind(t)}}function ct(t,n){const e=nt(t,n)-1;return S(t,n).map(r=>r/e)}function k(t){return{mapIndex(n,e,r){const a=t(n,e);if(a.length!==n.length)throw new Error("map function returned a mismatched length");for(let o=0,u=n.length;o<u;++o)r[n[o]]=a[o]}}}const it={mapIndex(t,n,e){let r=0;for(const a of t)e[a]=r+=n[a]}};export{dt as a,ht as d,ot as m};
